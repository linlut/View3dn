//main.cpp
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <vector>
#include <iostream>
#include <fstream>

using namespace std;
string glslDir;
string outputFile("./output.h");
vector<string> glslFiles;

void print_usage(void)
{
    std::cout << "glsl2c -d <glslfiles_dir> -o <headerfile> <list of glslfiles>\n";
    std::cout << "Example: glsl2c -d c:/glsl/ -o out.h vp1.glsl fp1.glsl vp2.glsl fp2.glsl\n";
}

static std::string loadTextFile(const std::string& name)
{
	std::ifstream file;
	file.open(name.c_str());
	if(file.fail()){
		std::cerr<<"loadFile: unable to open file: "<<name;
		return std::string("");
	}

	std::string buff;
	buff.reserve(16*1024);
	std::string srcline, line;
    srcline.reserve(1024);
    line.reserve(1024);

    while(std::getline(file, srcline)){
        if (srcline.length() == 0) continue;
        if (srcline.length() >= 2){
            if (srcline[0] == '/' && srcline[1] == '/') continue;
        }
        line.clear();
        bool prevSpace = false;
        for (unsigned int i=0; i<srcline.length(); i++){
            if (srcline[i] == ' ' && prevSpace) continue;
            if (srcline[i] == '\"') line.push_back('\\');
            line.push_back(srcline[i]);
            prevSpace = (srcline[i] == ' ');
        }
		buff += line + "\\n";
    }
	return buff;
}

void generate_headerfile(void)
{
	std::ofstream ofile;
	ofile.open(outputFile.c_str());
	if(ofile.fail()){
        std::cerr << "Error: unable to create file: " << outputFile << "\n";
		return;
	}
    ofile << "//Code generated by glsl2c. User should make no changes on this file!\n";
    ofile << "#pragma once\n";
    ofile << "#include <string>\n";
    ofile << "#include <map>\n";
    ofile << "namespace MeshRender{\n";
    ofile << "std::map<std::string, const char*> shadersMap;\n";
    ofile << "inline int shaderSourceInit(){\n";

    for (unsigned int i=0; i<glslFiles.size(); ++i){
        string key;
        string filename = glslDir + glslFiles[i];
        for (unsigned int i=0; i<filename.size(); i++){
            if (filename[i] == '\\') filename[i] = '/';
        }
        int pos = filename.rfind('/');
        if (pos == std::string::npos)
            key = filename;
        else 
            key = filename.substr(pos + 1);
        for (unsigned int j=0; j<key.length(); j++){
            if (key[j] == '.' || key[j] == '-')
                key[j] = '_';
        }
        string text = loadTextFile(filename);
        ofile << "    static const char* " << key << "=\"" << text << "\";\n";
        ofile << "    shadersMap[\"" << key << "\"]=" << key << ";\n";   
    }

    ofile << "    return 0;\n";
    ofile << "}//function shaderSourceInit\n";
    ofile << "static int runShaderSourceInit=shaderSourceInit();\n";
    ofile << "}//namespace MeshRender\n";
    ofile.close();
}

int main(int argc, char **argv)
{
    if (argc == 1){
        print_usage();
        return 0;
    }
    for (int i=0; i<argc; i++){
        std::cout << argv[i] << "\n";
    }

    for (int i=1; i<argc;){
        const char * p  = argv[i];
        if (p[0] == '-'){
            if (p[1] == 'd'){
                glslDir = argv[i+1];
                i += 2;
            }
            else if (p[1] == 'o'){
                outputFile = argv[i+1];
                i += 2;
            }
            else{
                std::cerr << "Unknown command '" << p << "'.\n";
                std::cerr << "Program aborted.\n";
                exit(-1);
            }
        }
        else{
            glslFiles.push_back(p);
            i++;
        }
    }

    if (glslDir.length() > 0){
        const int pos = glslDir.length() - 1;
        if (glslDir[pos] != '/' && glslDir[pos] != '\\'){
            glslDir.push_back('/');
        }
    }

    //do the work
    generate_headerfile();

    return 0;
}