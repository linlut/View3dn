//FILE: volumemeshio.cpp
#include <set>
#include <math.h>
#include <sysconf.h>
#include <vectorall.h>
#include <vector>
#include "volumemeshio.h"
#include "facetable.h"

using namespace std;


//===============Neutral mesh format, NETGEN MESH Output========================

static bool read_nodes(const char *innodefname, int& nv, Vector3d *& pVertex, int &startid)
{
	FILE *fpin;
	int i, tmp0, tmp1, tmp2;
	double x, y, z;

	fpin = fopen(innodefname, "r");
	assert(fpin!=NULL);
	fscanf(fpin, "%d %d %d %d", &nv, &tmp0, &tmp1, &tmp2);
	assert(nv>0 && tmp0==3);
	pVertex = new Vector3d[nv];
	assert(pVertex!=NULL);

	for (i=0; i<nv; i++){
		fscanf(fpin, "%d %lf %lf %lf", &tmp0, &x, &y, &z);
		if (i==0){
			assert(tmp0==0 || tmp0==1);
			startid=tmp0;
		}
		pVertex[i].x = x;
		pVertex[i].y = y;
		pVertex[i].z = z;
	}
	fclose(fpin);
	return true;
}


static bool read_face(const char *infacefname, const int startid, int& ntri, Vector3i *& pFace)
{
	int tmp0, tmp1;
	FILE *fpin = fopen(infacefname, "r");
	assert(fpin!=NULL);
	assert(startid==0 || startid==1);
	fscanf(fpin, "%d %d", &ntri, &tmp0);
	assert(ntri>0);
	assert(tmp0==0 || tmp0==1);
	pFace = new Vector3i[ntri];
	assert(pFace!=NULL);

	for (int i=0; i<ntri; i++){
		int n0, n1, n2;
		fscanf(fpin, "%d %d %d %d", &tmp1, &n0, &n1, &n2);
		if (startid==1){
			n0-=startid;
			n1-=startid;
			n2-=startid;
		}

		//reverse the triangle orientation because it is not correct!!
		pFace[i].x = n0, pFace[i].y = n2, pFace[i].z = n1; 
		if (tmp0==1) 
			fscanf(fpin, "%d", &tmp1); 
	}
	fclose(fpin);
	return true;
}


static bool read_ele(const char *inelefname, const int startid, int& ntet, Vector4i *& pFace)
{
	int tmp0, tmp1;
	//read/write elements;
	FILE *fpin = fopen(inelefname, "r");
	assert(fpin!=NULL);
	assert(startid==0 || startid==1);
	fscanf(fpin, "%d %d %d", &ntet, &tmp0, &tmp1);
	assert(ntet>0 && tmp0==4);
	pFace = new Vector4i[ntet];
	assert(pFace!=NULL);

	for (int i=0; i<ntet; i++){
		int n0, n1, n2, n3;
		fscanf(fpin, "%d %d %d %d %d", &tmp0, &n0, &n1, &n2, &n3);
		if (startid==1){
			n0-=startid;
			n1-=startid;
			n2-=startid;
			n3-=startid;		
		}
		pFace[i].x=n0;
		pFace[i].y=n1;
		pFace[i].z=n2;
		pFace[i].w=n3;
	}
	fclose(fpin);
	return true;
}



//Read neutral mesh file format generated by NETGEN
//
static Vector3d* read_netgen_neutralfile_nodes(FILE *fpin, int& nv)
{
	fscanf(fpin, "%d", &nv);
	Vector3d *pVertex = new Vector3d[nv];
	assert(pVertex!=NULL);
	for (int i=0; i<nv; i++){
		double x, y, z;
		Vector3d * v = &pVertex[i];
		fscanf(fpin, "%lf %lf %lf", &x, &y, &z);
		v->x = x, v->y = y, v->z = z;
	}
	return pVertex;
}

static int* read_netgen_neutralfile_elms(FILE *fpin, int& ntet, int &mshtype)
{
	int i, tmp0, nstep, n[8];

	fscanf(fpin, "%d", &ntet);
	assert(ntet>0);
	fscanf(fpin, "%d %d %d %d %d", &mshtype, &n[0], &n[1], &n[2], &n[3]);
	assert(mshtype==1 || mshtype==2);
	if (mshtype==1)
		nstep = 4;
	else{ 
		nstep = 8;
		fscanf(fpin, "%d %d %d %d", &n[4], &n[5], &n[6], &n[7]);
	}

	int *pFace = new int [nstep*ntet];
	assert(pFace!=NULL);
	for (i=0; i<nstep; i++) pFace[i]=n[i]-1;

	for (int j=1; j<ntet; j++, i+=nstep){
		int *a = &pFace[i];
		switch(mshtype){
		case 1:  
			fscanf(fpin, "%d %d %d %d %d", &tmp0, &a[0], &a[1], &a[2], &a[3]);
			a[0]--, a[1]--; a[2]--, a[3]--;
			break;
		case 2:
			fscanf(fpin, "%d %d %d %d %d %d %d %d %d", 
				&tmp0, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7]);
			a[0]--, a[1]--; a[2]--, a[3]--;
			a[4]--, a[5]--; a[6]--, a[7]--;
			break;
		default:
			assert(0);
			break;
		}
		assert(tmp0==mshtype);
	}
	return pFace;
}


static int* read_netgen_neutralfile_face(const int meshtype, FILE *fpin, int& ntri)
{
	assert(meshtype==1 || meshtype==2);
	fscanf(fpin, "%d", &ntri);
	assert(ntri>0);
	int* pFace = new int [ntri*(2+meshtype)];
	assert(pFace!=NULL);
	int c=0;
	for (int i=0; i<ntri; i++){
		int n0, n1, n2, n3, tmp1;
		if (meshtype==1){
			fscanf(fpin, "%d %d %d %d", &tmp1, &n0, &n1, &n2);
			pFace[c++] = n0-1, pFace[c++] = n1-1, pFace[c++] = n2-1; 
		}
		else{
			fscanf(fpin, "%d %d %d %d %d", &tmp1, &n0, &n1, &n2, &n3);
			pFace[c++] = n0-1, pFace[c++] = n1-1, 
			pFace[c++] = n2-1; pFace[c++] = n3-1; 
		}
	}
	return pFace;
}


static void check_elms(const Vector3d *pVertex, Vector4i *pElem, const int ntet)
{
	assert(pElem!=NULL);
	assert(pVertex!=NULL);
	for (int i=0; i<ntet; i++){
		Vector4i & tet = pElem[i];
		const Vector3d *p1 = &pVertex[tet.x];
		const Vector3d *p2 = &pVertex[tet.y];
		const Vector3d *p3 = &pVertex[tet.z];
		const Vector3d *p4 = &pVertex[tet.w];
		Vector3d e1 = (*p2) - (*p1);
		Vector3d e2 = (*p3) - (*p2);
		Vector3d e3 = (*p4) - (*p1);
		Vector3d n = CrossProd(e1, e2);
		double r = DotProd(n, e3);
		if (r<0){ //need to change orientation of the element;
			int itmp = tet.z;
			tet.z = tet.y;
			tet.y = itmp;
		}
	}
}


bool loadNeutralMeshFile(const char *fname, 
	Vector3d *& pVertex, int &nv, 
	int *& pFace, int &ntri,
	int *& pTet, int &ntet, int &meshtype)
{
	//read files;
	FILE *fp = fopen(fname, "r");
	if (fp==NULL) return false;
	pVertex = read_netgen_neutralfile_nodes(fp, nv);
	pTet = read_netgen_neutralfile_elms(fp, ntet, meshtype);
	assert(meshtype==1 || meshtype==2);
	pFace = read_netgen_neutralfile_face(meshtype, fp, ntri);
	fclose(fp);

	//check the orientation;
	if (meshtype==1) //tet mesh
		check_elms(pVertex, (Vector4i*)pTet, ntet);
	return true;
}



//===================OFF, OFFV volumetric data=======================


static void read_off_nodes(FILE *fpin, const int nv, Vector3d *&pVertex, float *&pIsoValue)
{
	pVertex = new Vector3d[nv];
	pIsoValue = new float[nv];
	assert(pVertex!=NULL && pIsoValue!=NULL);
	for (int i=0; i<nv; i++){
		double x, y, z, iso;
		fscanf(fpin, "%lf %lf %lf %lf", &x, &y, &z, &iso);
		pVertex[i] = Vector3d(x, y, z);
		pIsoValue[i] = iso;
	}
}

static int* read_off_elms(FILE *fpin, const int ntet, int &mshtype)
{
	int i=0;
	assert(ntet>0);
	mshtype =1; //tet mesh
	const int nstep = 4;

	int *pFace = new int [nstep*ntet];
	assert(pFace!=NULL);

	for (int j=0; j<ntet; j++, i+=nstep){
		int *a = &pFace[i];
		fscanf(fpin, "%d %d %d %d", &a[0], &a[1], &a[2], &a[3]);
		//a[0]--, a[1]--; a[2]--, a[3]--;
	}
	return pFace;
}


bool loadOffMeshFile(const char *fname, 
	Vector3d *& pVertex, int &nv, 
	float*& pIsoValue, 
	int *& pFace, int &ntri,
	int *& pTet, int &ntet, int &meshtype)
{
	//read files;
	FILE *fp = fopen(fname, "r");
	if (fp==NULL){
		printf("Read file: %s failed.\n", fname);
		return false;
	}

	//read basic info.
	fscanf(fp, "%d %d", &nv, &ntet);
	read_off_nodes(fp, nv, pVertex, pIsoValue);
	pTet = read_off_elms(fp, ntet, meshtype);
	assert(meshtype==1);
	fclose(fp);

	//check the orientation;
	if (meshtype==1) //tet mesh
		check_elms(pVertex, (Vector4i*)pTet, ntet);

	//generate the boundary
	FaceTable ft;
	ft.buildFaceTable(nv, (Vector4i*)pTet, ntet);
	pFace = (int*)ft.collectFaces((Vector4i*)pTet, ntet, ntri);

	return true;
}




//=============HYPERMESH ASCII FILE FORMAT===========================

static int seekZoneInFile(FILE *fp, const char *seekname, bool startfromheadpos=false)
{
	const int SBUFFER_LENGTH=1024;
	char sbuffer[SBUFFER_LENGTH+1];

	//read ZONE line
	if (startfromheadpos )
		fseek(fp, 0, SEEK_SET);

	do{
		fgets(sbuffer, SBUFFER_LENGTH, fp);	  
		const char* foundheader = strstr(sbuffer, seekname);
		if (foundheader) 
			return true;
	}while (!feof(fp)); 

	return 0;
}


static void ungetLine(const char *str, FILE *fp)
{
	const char ch1= 0xd;
	const char ch2 = 0xa;
#ifdef WIN32
	//ungetc(ch2, fp);
	//ungetc(ch1, fp);
#else
	//ungetc(ch1, fp);
#endif
	int slen = strlen(str);
	for (int i=slen-1; i>=0; i--){
		ungetc(str[i], fp);
	}
}


static Vector3d *_read_hm_nodes(FILE *fp, int &nv)
{
	const int NN = 1024000;
	char sbuffer[1025];
	char strendnode[]="END NODES";
	int i;

	//read the file
	vector<Vector3d> vv;
	vv.resize(NN);
	for (i=0; i<NN; i++) vv[i] = Vector3d(0);
	nv = 0;

	while(!feof(fp)){
		sbuffer[0]=0;
		fgets(sbuffer, 1024, fp);
		if (sbuffer[0]==0xd || sbuffer[0]==0xa) 
			continue;
		char *pstr = &sbuffer[0];
		while (*pstr==' ') pstr++;
		if (strncmp(pstr, "*node(", 6)!=0){
			if (strncmp(pstr, strendnode, 9)==0) 
				break;
			else
				continue;
		}
		//A line in hm ascii file will look like this:
		//*node(1,4.606422,26.934855,3.476964,0,0,0,0,0)
		int id;
		double x, y, z, tx, ty, tz, ux, uy;
		const int slen = strlen(pstr);
		for (i=0; i<slen; i++){
			if (pstr[i]==',') pstr[i]=' ';
		}
		sscanf(pstr, "*node(%d %lf %lf %lf %lf %lf %lf %lf %lf)", &id, &x, &y, &z, &tx, &ty, &tz, &ux, &uy);
		if (id>NN){
			printf("HMASCII::Reading vertex overflow!\n");
			assert(0);
		}
		vv[id-1] = Vector3d(x,y,z);
		nv = _MAX_(nv, id);
	}

	//copy the vertices;
	assert(nv!=0);
	Vector3d *p = new Vector3d[nv]; 
	assert(p!=NULL);
	for (i=0; i<nv; i++) p[i]=vv[i];

	return p;
}



static int* _read_hm_elms(FILE *fp, int &ntet, int &meshtype)
{
	//read the file
	char sbuffer[1025];
	vector<Vector4i> elm;
	elm.resize(10240);
	elm.clear();

	while (!feof(fp)){
		sbuffer[0]=0;
		fgets(sbuffer, 1024, fp);
		if (sbuffer[0]==0xd || sbuffer[0]==0xa) 
			continue;
		char *pstr = &sbuffer[0];
		while (*pstr==' ') pstr++;
		if (strncmp(pstr, "*tetra4", 6)!=0){
			ungetLine(pstr, fp);
			break;
		}
		
		//A line in hm ascii file will look like this for triangle input:
		//*tetra4(4,1,215,5,4,254)
		int id, itype, a, b, c, d;
		sscanf(pstr, "*tetra4(%d,%d,%d,%d,%d,%d)", &id, &itype, &a, &b, &c, &d);
		a--, b--, c--, d--;
		Vector4i e0(a, b, c, d);
		elm.push_back(e0);
	}

	//copy the vertices;
	ntet = elm.size();
	assert(ntet!=0);
	Vector4i *pelm = new Vector4i[ntet]; 
	assert(pelm!=NULL);
	for (int i=0; i<ntet; i++)
		pelm[i] = elm[i];

	int *p = (int*)pelm;
	meshtype=1;
	return p;
}


static int* _read_hm_face(const int meshtype, FILE *fp, int &ntri)
{
	//read the file
	char sbuffer[1025];
	vector<Vector3i> tri;
	tri.resize(10240);
	tri.clear();

	while (!feof(fp)){
		sbuffer[0]=0;
		fgets(sbuffer, 1024, fp);
		if (sbuffer[0]==0xd || sbuffer[0]==0xa) 
			continue;
		char *pstr = &sbuffer[0];
		while (*pstr==' ') pstr++;
		if (strncmp(pstr, "*tria3(", 7)!=0){
			ungetLine(pstr, fp);
			break;
		}
		
		//A line in hm ascii file will look like this for triangle input:
		//*tria3(500,1,206,66,231)
		int id, itype, a, b, c;
		sscanf(pstr, "*tria3(%d,%d,%d,%d,%d)", 
					&id, &itype, &a, &b, &c);
		a--, b--, c--;
		Vector3i t0(a, b, c);
		tri.push_back(t0);
	}

	//copy the vertices;
	ntri = tri.size();
	assert(ntri!=0);
	Vector3i *ptri = new Vector3i[ntri]; 
	assert(ptri!=NULL);
	for (int i=0; i<ntri; i++)
		ptri[i] = tri[i];

	int *p = (int*)ptri;
	return p;
}


bool loadHMAsciiMeshFile(const char *fname, 
	Vector3d *& pVertex, int &nv, 
	int *& pFace, int &ntri,
	int *& pTet, int &ntet, int &meshtype)
{
	pVertex = NULL;
	pFace = NULL;
	pTet = NULL;
	char s1[]="BEGIN DATA";
	char s2[]="BEGIN NODES";
	char s4[]="BEGIN COMPONENTS";
	char s5[]="*component";
	char sbuffer[1025];
	int r;
	const bool startfromheadpos=true;

	//open files;
	FILE *fp = fopen(fname, "r");
	if (fp==NULL) goto ERROR_PROCESS;

	//skip ZONE, read vertices
	r = seekZoneInFile(fp, s1, startfromheadpos);
	if (!r) goto ERROR_PROCESS;
	r = seekZoneInFile(fp, s2);
	if (!r) goto ERROR_PROCESS;
	pVertex = _read_hm_nodes(fp, nv);

	//read componets
	r = seekZoneInFile(fp, s4);
	if (!r) return false;
	r = seekZoneInFile(fp, s5);
	if (!r) return false;
	
	fgets(sbuffer, 1024, fp);
	ungetLine(sbuffer, fp);

	if (strncmp(sbuffer, "*tria3", 6)==0){
		pFace = _read_hm_face(meshtype, fp, ntri);

		r = seekZoneInFile(fp, s5);
		if (!r) goto ERROR_PROCESS;
		pTet = _read_hm_elms(fp, ntet, meshtype);
	}
	else if (strncmp(sbuffer, "*tetra4", 7)==0){
		pTet = _read_hm_elms(fp, ntet, meshtype);

		r = seekZoneInFile(fp, s5);
		if (!r) goto ERROR_PROCESS;
		pFace = _read_hm_face(meshtype, fp, ntri);
	}

	fclose(fp);

	//check the orientation;
	assert(meshtype==1 || meshtype==2);
	if (meshtype==1){ //tet mesh
		check_elms(pVertex, (Vector4i*)pTet, ntet);
	}
	return true;


ERROR_PROCESS:
	if (fp) fclose(fp);
	SafeDeleteArray(pVertex);
	SafeDeleteArray(pFace);
	SafeDeleteArray(pTet);
	return false;
}


static void test()
{
	char *fname="e:/incoming/GeometrySurface.hmascii";

	Vector3d * pVertex;
	int nv;
	int *pFace;
	int ntri;
	int *pTet;
	int ntet;
	int meshtype;

	bool r = loadHMAsciiMeshFile(fname, 
					pVertex, nv, 
					pFace, ntri,
					pTet, ntet, 
					meshtype);

}
